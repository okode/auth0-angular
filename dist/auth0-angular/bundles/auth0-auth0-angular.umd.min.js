!(function (t, e) {
  'object' == typeof exports && 'undefined' != typeof module
    ? e(
        exports,
        require('@angular/core'),
        require('@auth0/auth0-spa-js'),
        require('rxjs'),
        require('rxjs/operators'),
        require('@angular/router'),
        require('@angular/common')
      )
    : 'function' == typeof define && define.amd
    ? define('@auth0/auth0-angular', [
        'exports',
        '@angular/core',
        '@auth0/auth0-spa-js',
        'rxjs',
        'rxjs/operators',
        '@angular/router',
        '@angular/common',
      ], e)
    : e(
        (((t =
          'undefined' != typeof globalThis ? globalThis : t || self).auth0 =
          t.auth0 || {}),
        (t.auth0['auth0-angular'] = {})),
        t.ng.core,
        t.auth0SpaJs,
        t.rxjs,
        t.rxjs.operators,
        t.ng.router,
        t.ng.common
      );
})(this, function (t, e, n, r, i, o, a) {
  'use strict';
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */ Object.create;
  Object.create;
  var u = '@auth0/auth0-angular',
    c = '1.3.2',
    s = (function () {
      function t() {}
      return (
        (t.createClient = function (t) {
          var e = t.get();
          if (!e)
            throw new Error(
              'Configuration must be specified either through AuthModule.forRoot or through AuthClientConfig.set'
            );
          var r = e.redirectUri,
            i = e.clientId,
            o = e.maxAge,
            a =
              (e.httpInterceptor,
              (function (t, e) {
                var n = {};
                for (var r in t)
                  Object.prototype.hasOwnProperty.call(t, r) &&
                    e.indexOf(r) < 0 &&
                    (n[r] = t[r]);
                if (
                  null != t &&
                  'function' == typeof Object.getOwnPropertySymbols
                ) {
                  var i = 0;
                  for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
                    e.indexOf(r[i]) < 0 &&
                      Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
                      (n[r[i]] = t[r[i]]);
                }
                return n;
              })(e, ['redirectUri', 'clientId', 'maxAge', 'httpInterceptor']));
          return new n.Auth0Client(
            Object.assign(
              Object.assign(
                {
                  redirect_uri: r || window.location.origin,
                  client_id: i,
                  max_age: o,
                },
                a
              ),
              { auth0Client: { name: u, version: c } }
            )
          );
        }),
        t
      );
    })(),
    p = new e.InjectionToken('auth0.client'),
    h = (function () {
      function t(t, e) {
        this.location = t;
        try {
          this.router = e.get(o.Router);
        } catch (t) {}
      }
      return (
        (t.prototype.navigateByUrl = function (t) {
          this.router
            ? this.router.navigateByUrl(t)
            : this.location.replaceState(t);
        }),
        t
      );
    })();
  function l(t) {
    return void 0 !== t.uri;
  }
  (h.ɵprov = e.ɵɵdefineInjectable({
    factory: function () {
      return new h(e.ɵɵinject(a.Location), e.ɵɵinject(e.INJECTOR));
    },
    token: h,
    providedIn: 'root',
  })),
    (h.decorators = [{ type: e.Injectable, args: [{ providedIn: 'root' }] }]),
    (h.ctorParameters = function () {
      return [{ type: a.Location }, { type: e.Injector }];
    });
  var f = (function () {
    function t(t) {
      t && this.set(t);
    }
    return (
      (t.prototype.set = function (t) {
        this.config = t;
      }),
      (t.prototype.get = function () {
        return this.config;
      }),
      t
    );
  })();
  (f.ɵprov = e.ɵɵdefineInjectable({
    factory: function () {
      return new f(e.ɵɵinject(d, 8));
    },
    token: f,
    providedIn: 'root',
  })),
    (f.decorators = [{ type: e.Injectable, args: [{ providedIn: 'root' }] }]),
    (f.ctorParameters = function () {
      return [
        {
          type: void 0,
          decorators: [{ type: e.Optional }, { type: e.Inject, args: [d] }],
        },
      ];
    });
  var d = new e.InjectionToken('auth0-angular.config'),
    g = (function () {
      function t(t, e, n, o) {
        var a = this;
        (this.auth0Client = t),
          (this.configFactory = e),
          (this.location = n),
          (this.navigator = o),
          (this.isLoadingSubject$ = new r.BehaviorSubject(!0)),
          (this.errorSubject$ = new r.ReplaySubject(1)),
          (this.refreshState$ = new r.Subject()),
          (this.ngUnsubscribe$ = new r.Subject()),
          (this.isLoading$ = this.isLoadingSubject$.asObservable()),
          (this.isAuthenticatedTrigger$ = this.isLoading$.pipe(
            i.filter(function (t) {
              return !t;
            }),
            i.distinctUntilChanged(),
            i.switchMap(function () {
              return r.merge(
                r.defer(function () {
                  return a.auth0Client.isAuthenticated();
                }),
                a.refreshState$.pipe(
                  i.mergeMap(function () {
                    return a.auth0Client.isAuthenticated();
                  })
                )
              );
            })
          )),
          (this.isAuthenticated$ = this.isAuthenticatedTrigger$.pipe(
            i.distinctUntilChanged()
          )),
          (this.user$ = this.isAuthenticatedTrigger$.pipe(
            i.concatMap(function (t) {
              return t ? a.auth0Client.getUser() : r.of(null);
            })
          )),
          (this.idTokenClaims$ = this.isAuthenticatedTrigger$.pipe(
            i.concatMap(function (t) {
              return t ? a.auth0Client.getIdTokenClaims() : r.of(null);
            })
          )),
          (this.error$ = this.errorSubject$.asObservable());
        this.shouldHandleCallback()
          .pipe(
            i.switchMap(function (t) {
              return (function (t) {
                return r.iif(
                  function () {
                    return t;
                  },
                  a.handleRedirectCallback(),
                  r.defer(function () {
                    return a.auth0Client.checkSession();
                  })
                );
              })(t).pipe(
                i.catchError(function (t) {
                  var e = a.configFactory.get();
                  return (
                    a.errorSubject$.next(t),
                    a.navigator.navigateByUrl(e.errorPath || '/'),
                    r.of(void 0)
                  );
                })
              );
            }),
            i.tap(function () {
              a.isLoadingSubject$.next(!1);
            }),
            i.takeUntil(this.ngUnsubscribe$)
          )
          .subscribe();
      }
      return (
        (t.prototype.ngOnDestroy = function () {
          this.ngUnsubscribe$.next(), this.ngUnsubscribe$.complete();
        }),
        (t.prototype.loginWithRedirect = function (t) {
          return r.from(this.auth0Client.loginWithRedirect(t));
        }),
        (t.prototype.loginWithPopup = function (t, e) {
          var n = this;
          return r.from(
            this.auth0Client.loginWithPopup(t, e).then(function () {
              n.refreshState$.next();
            })
          );
        }),
        (t.prototype.logout = function (t) {
          this.auth0Client.logout(t),
            (null == t ? void 0 : t.localOnly) && this.refreshState$.next();
        }),
        (t.prototype.getAccessTokenSilently = function (t) {
          var e = this;
          return r.of(this.auth0Client).pipe(
            i.concatMap(function (e) {
              return e.getTokenSilently(t);
            }),
            i.tap(function () {
              return e.refreshState$.next();
            }),
            i.catchError(function (t) {
              return (
                e.errorSubject$.next(t), e.refreshState$.next(), r.throwError(t)
              );
            })
          );
        }),
        (t.prototype.getAccessTokenWithPopup = function (t) {
          var e = this;
          return r.of(this.auth0Client).pipe(
            i.concatMap(function (e) {
              return e.getTokenWithPopup(t);
            }),
            i.tap(function () {
              return e.refreshState$.next();
            }),
            i.catchError(function (t) {
              return (
                e.errorSubject$.next(t), e.refreshState$.next(), r.throwError(t)
              );
            })
          );
        }),
        (t.prototype.auth0HandleCallback = function (t) {
          var e = this;
          ((null == t ? void 0 : t.includes('code=')) ||
            (null == t ? void 0 : t.includes('error='))) &&
            (null == t ? void 0 : t.includes('state=')) &&
            r
              .from(this.auth0Client.handleRedirectCallback(t))
              .pipe(
                i.map(function (t) {
                  var n = '/';
                  t &&
                    t.appState &&
                    t.appState.target &&
                    (n = t.appState.target),
                    e.navigator.navigateByUrl(n);
                }),
                i.tap(function () {
                  e.refreshState$.next(), e.isLoadingSubject$.next(!1);
                }),
                i.takeUntil(this.ngUnsubscribe$)
              )
              .subscribe();
        }),
        (t.prototype.shouldHandleCallback = function () {
          var t = this;
          return r.of(this.location.path()).pipe(
            i.map(function (e) {
              return (
                (e.includes('code=') || e.includes('error=')) &&
                e.includes('state=') &&
                !t.configFactory.get().skipRedirectCallback
              );
            })
          );
        }),
        (t.prototype.handleRedirectCallback = function () {
          var t = this;
          return r
            .defer(function () {
              return t.auth0Client.handleRedirectCallback();
            })
            .pipe(
              i.tap(function (e) {
                var n,
                  r,
                  i =
                    null !==
                      (r =
                        null === (n = null == e ? void 0 : e.appState) ||
                        void 0 === n
                          ? void 0
                          : n.target) && void 0 !== r
                      ? r
                      : '/';
                t.navigator.navigateByUrl(i);
              })
            );
        }),
        t
      );
    })();
  (g.ɵprov = e.ɵɵdefineInjectable({
    factory: function () {
      return new g(
        e.ɵɵinject(p),
        e.ɵɵinject(f),
        e.ɵɵinject(a.Location),
        e.ɵɵinject(h)
      );
    },
    token: g,
    providedIn: 'root',
  })),
    (g.decorators = [{ type: e.Injectable, args: [{ providedIn: 'root' }] }]),
    (g.ctorParameters = function () {
      return [
        { type: n.Auth0Client, decorators: [{ type: e.Inject, args: [p] }] },
        { type: f },
        { type: a.Location },
        { type: h },
      ];
    });
  var y = (function () {
    function t(t) {
      this.auth = t;
    }
    return (
      (t.prototype.canLoad = function (t, e) {
        return this.auth.isAuthenticated$.pipe(i.take(1));
      }),
      (t.prototype.canActivate = function (t, e) {
        return this.redirectIfUnauthenticated(e);
      }),
      (t.prototype.canActivateChild = function (t, e) {
        return this.redirectIfUnauthenticated(e);
      }),
      (t.prototype.redirectIfUnauthenticated = function (t) {
        var e = this;
        return this.auth.isAuthenticated$.pipe(
          i.tap(function (n) {
            return n
              ? r.of(!0)
              : e.auth.loginWithRedirect({ appState: { target: t.url } });
          })
        );
      }),
      t
    );
  })();
  (y.ɵprov = e.ɵɵdefineInjectable({
    factory: function () {
      return new y(e.ɵɵinject(g));
    },
    token: y,
    providedIn: 'root',
  })),
    (y.decorators = [{ type: e.Injectable, args: [{ providedIn: 'root' }] }]),
    (y.ctorParameters = function () {
      return [{ type: g }];
    });
  var v = (function () {
    function t() {}
    return (
      (t.forRoot = function (e) {
        return {
          ngModule: t,
          providers: [
            g,
            y,
            { provide: d, useValue: e },
            { provide: p, useFactory: s.createClient, deps: [f] },
          ],
        };
      }),
      t
    );
  })();
  v.decorators = [{ type: e.NgModule }];
  var b = (function () {
    function t(t, e) {
      (this.configFactory = t), (this.authService = e);
    }
    return (
      (t.prototype.intercept = function (t, e) {
        var n,
          o = this,
          a = this.configFactory.get();
        return (
          null === (n = a.httpInterceptor) || void 0 === n
            ? void 0
            : n.allowedList
        )
          ? this.findMatchingRoute(t, a.httpInterceptor).pipe(
              i.concatMap(function (n) {
                return r.iif(
                  function () {
                    return null !== n;
                  },
                  r.of(n).pipe(
                    i.pluck('tokenOptions'),
                    i.concatMap(function (t) {
                      return o.authService.getAccessTokenSilently(t);
                    }),
                    i.switchMap(function (n) {
                      var r = t.clone({
                        headers: t.headers.set('Authorization', 'Bearer ' + n),
                      });
                      return e.handle(r);
                    })
                  ),
                  e.handle(t)
                );
              })
            )
          : e.handle(t);
      }),
      (t.prototype.stripQueryFrom = function (t) {
        return (
          t.indexOf('?') > -1 && (t = t.substr(0, t.indexOf('?'))),
          t.indexOf('#') > -1 && (t = t.substr(0, t.indexOf('#'))),
          t
        );
      }),
      (t.prototype.canAttachToken = function (t, e) {
        var n = this,
          r = function (t) {
            return (
              t && t.trim(),
              !!t &&
                (t === n.stripQueryFrom(e.url) ||
                  (t.indexOf('*') === t.length - 1 &&
                    e.url.startsWith(t.substr(0, t.length - 1))))
            );
          };
        return l(t)
          ? (!t.httpMethod || t.httpMethod === e.method) && r(t.uri)
          : r(t);
      }),
      (t.prototype.findMatchingRoute = function (t, e) {
        var n = this;
        return r.from(e.allowedList).pipe(
          i.first(function (e) {
            return n.canAttachToken(e, t);
          }, null)
        );
      }),
      t
    );
  })();
  (b.decorators = [{ type: e.Injectable }]),
    (b.ctorParameters = function () {
      return [{ type: f }, { type: g }];
    }),
    (t.AuthClientConfig = f),
    (t.AuthConfigService = d),
    (t.AuthGuard = y),
    (t.AuthHttpInterceptor = b),
    (t.AuthModule = v),
    (t.AuthService = g),
    (t.isHttpInterceptorRouteConfig = l),
    (t.ɵa = s),
    (t.ɵb = p),
    (t.ɵc = h),
    Object.defineProperty(t, '__esModule', { value: !0 });
});
//# sourceMappingURL=auth0-auth0-angular.umd.min.js.map
